## 电量优化套路总结

### 优化应用的后台耗电

避免后台长时间获取WakeLock、WIFI和蓝牙的扫描等。



### 符合系统的耗电规则

Android P使用了Android Vitals监控后台耗电，其规则如下所示：

* Alarm Manager wakeup 唤醒过多；当手机不在充电状态，每小时wakeup唤醒次数大于10次。
* 频繁使用局部唤醒锁：当手机不在充电状态，partial wake lock持有超过1小时。
* 后台网络使用量过高：当手机不在充电状态而且应用在后台，每小时网络使用量好过50MB。
* 后台WIFI scans过多：当手机不在充电状态而且应用在后台，每小时大于4次Wifi scans。



### CPU时间片

Android手机保护AP和BP两个CPU。AP即**Application Processor**，所有的用户界面以及App都是运行在AP上的。BP即**Baseband Processor**，手机射频都是运行在这个CPU上的。而一般我们所说的耗电，PowerProfile文件里边的CPU，指的是AP。

CPU耗电通常有两种情况：

* 长期频繁唤醒：原本可以仅仅在BP上运行，消耗5mA左右，但是因为唤醒，AP就会运行，不同手机情况会不一样，至少导致20~30mA左右的耗电。
* CPU长期高负荷：例如App退到后台的时候没有停止动画，或者程序有不退出的死循环等等，导致CPU满频、满核地跑。

常用优化CPU时间片的方式有：

* 获取运行过程线程CPU消耗，定位CPU占用率异常方法。
* 减少后台应用的主动运行。



### 网络相关

通常情况下，使用WIFI连接网络时的功耗要低于使用移动网络的功耗。而使用移动网络传输数据，电量的消耗有以下3种状态：

* Full Power：高功率状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。
* Low Power：低功率状态，对电量的消耗差不多是Full Power状态下的50%。
* Standby：空闲态，没有数据连接需要传输，电量消耗最少。

因此，为了避免网络连接所带来的电量消耗，我们可以采用如下几种方案：

* 尽量在WIFI环境下进行数据传输，在使用WIFI传输数据时，应该尽可能增大每个包的大小（不超过MTU），并降低发包的频率。
* 在蜂窝移动网络下需要对请求时机及次数控制：可以延迟执行的网络请求稍后一起发送，最好做到批量执行，尽量避免频繁的间隔网络请求，以尽量多地保持在Radio Standby状态。
* 使用JSON和Protobuf进行数据压缩，减少时间。
* 禁止使用轮询功能：轮询会导致网络请求一直处于被激活状态，耗电过高。



### 定位相关

* 根据场景谨慎选择定位模式：对定位准确度没那么高的场景可以选择低精度模式。
* 可以考虑网络定位替代GPS。
* 使用后务必及时关闭，减少更新频率，例如定位开启一段时间后超过某个阈值可以执行一个兜底策略：强制关闭GPS



### 界面相关

* 离开界面后停止相关活动，例如关闭动画。
* 耗电操作判断前后台，如果是后台则不执行相关操作。



### WakeLock相关

WakeLock常用于后台播放音视频、录制音视频、下载文件的情况。如果没有合理使用WakeLock，则会造成严重的耗电问题。关于WakeLock的使用我们要着重注意一下几点：

* 注意成对使用acquire、release。
* 建议使用带参数的acquire，避免没有及时释放而导致电量消耗过大。
* 使用finally确保release一定会被调用。
* 常亮场景使用keepScreenOn即可。
* WakeLock有一个接口setReferenceCounted，用来设置WakeLock的计数机制。



### 计算优化

浮点数运算比整数运算更消耗CPU时间片，因此耗电也会增加。避开浮点数运算的优化方法：

* 除法变乘法
* 充分利用移位
* 在native层开发时，可以利用ARM neon指令集做并行运算



### 灭屏时停止动画

监听灭屏以及亮屏的广播，在灭屏的时候停止surfaceview的动画绘制。在亮屏的时候恢复动画的绘制。



## 耗电监控

以后台耗电监控为主，必须监控的模块有：

* Alarm wakeup
* WakeLock
* Wifi Scan
* Network

必须监控的场景信息有：

* 堆栈信息
* 是否充电
* 电量水平
* 应用前后台信息
* CPU状态信息

